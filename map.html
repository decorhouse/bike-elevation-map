<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
      html { height: 100% }
      body { height: 100%; margin: 0; padding: 0 }
      #map_canvas { height: 100% }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js"></script>
    <!-- include the geometry library -->
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?libraries=geometry&sensor=false"></script>
    <script type="text/javascript">

    /* Gradient color functions

       Thanks to stackoverflow: http://stackoverflow.com/questions/8732401/how-to-figure-out-all-colors-in-a-gradient
    */

    function makeGradientColor(color1, color2, percent) {
        var newColor = {};

        function makeChannel(a, b) {
            return(a + Math.round((b-a)*(percent)));
        }

        function makeColorPiece(num) {
            num = Math.min(num, 255);   // not more than 255
            num = Math.max(num, 0);     // not less than 0
            var str = num.toString(16);
            if (str.length < 2) {
                str = "0" + str;
            }
            return(str);
        }

        newColor.r = makeChannel(color1.r, color2.r);
        newColor.g = makeChannel(color1.g, color2.g);
        newColor.b = makeChannel(color1.b, color2.b);
        newColor.cssColor = "#" +
                            makeColorPiece(newColor.r) +
                            makeColorPiece(newColor.g) +
                            makeColorPiece(newColor.b);
        return newColor.cssColor;
    }

      function initialize() {

        // See here for features: https://developers.google.com/maps/documentation/javascript/styling#map_features
        // https://developers.google.com/maps/documentation/javascript/reference#MapTypeStyleFeatureType
        var styleArray = [
          {
            featureType: "all",
            stylers: [
              { saturation: -80 }
            ]
          },{
            featureType: "road.arterial",
            elementType: "geometry",
            stylers: [
              { hue: "#00ffee" },
              { saturation: 50 }
            ]
          },{
            featureType: "poi.business",
            elementType: "labels",
            stylers: [
              { visibility: "off" }
            ]
          }
        ];

        var mapOptions = {
          center: new google.maps.LatLng(37.770443,-122.448172),
          zoom: 13,
          mapTypeId: google.maps.MapTypeId.ROADMAP,
          styles: styleArray,
        };
        var map = new google.maps.Map(document.getElementById("map_canvas"),
            mapOptions);


        $.getJSON('new-test.json', function(area_data) {
            console.log(area_data);
            for (var street in area_data['paths']) {
                //console.log(street);

                for (var index in area_data['paths'][street]) {
                    index = parseInt(index);
                    // Skip if we are on a break!!
                    if (area_data['paths'][street][index] == 'BREAK') {
                        continue;
                    }
                    //console.log(area_data['streets'][street]);
                    var point1 = area_data['intersections'][area_data['paths'][street][index]];
                    if (point1 == undefined) {
                        //console.log('undefined points, continuing...');
                        continue;
                    }

                    // for each point, add a marker that shows up only on mouseover.
                    /*
                    var marker = new google.maps.Marker({
                        map: map,
                        position: new google.maps.LatLng(point1['lat'], point1['lng']),
                        title: area_data['paths'][street][index],
                        visible: true,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 1
                        }
                    });
                    google.maps.event.addListener(marker, 'mouseover', function(event) { this.setOptions({visible: true}); });
                    google.maps.event.addListener(marker, 'mouseout', function(event) { this.setOptions({visible: false}); });
                    */

                    if ((index + 1) >= area_data['paths'][street].length) {
                        //console.log('continued');
                        continue;
                    }

                    // If the second point is a break, continue as well.
                    if (area_data['paths'][street][index+1] == 'BREAK') {
                        console.log('hit a break!! front end');
                        console.log(area_data['paths'][street][index]);
                        continue;
                    }


                    var point2 = area_data['intersections'][area_data['paths'][street][index+1]];
                    //console.log(point1, point2);
                    if (point1 == undefined || point2 == undefined) {
                        //console.log('undefined points, continuing...');
                        continue;
                    }
                    var lineCoordinates = [
                        new google.maps.LatLng(point1['lat'], point1['lng']),
                        new google.maps.LatLng(point2['lat'], point2['lng']),
                    ];
                    //console.log(area_data['paths'][street][index], area_data['paths'][street][index+1]);
                    //console.log(point1['elevation'], point2['elevation']);

                    /* ARROWS POINT DOWNHILL */
                    var arrowPoint = google.maps.SymbolPath.FORWARD_OPEN_ARROW;
                    var arrowLocation = '100%';

                    if (point1['elevation'] < point2['elevation']) { // uphill
                        arrowPoint = google.maps.SymbolPath.BACKWARD_OPEN_ARROW;
                        arrowLocation = '0%';
                    }

                    var lineSymbol = {
                      path: arrowPoint
                      // https://developers.google.com/maps/documentation/javascript/reference#Symbol
                    };

                    var elevation_diff = Math.abs(point1['elevation'] - point2['elevation']);
                    var run_distance = google.maps.geometry.spherical.computeDistanceBetween(lineCoordinates[0], lineCoordinates[1]);
                    console.log(elevation_diff, run_distance);
                    console.log(area_data['paths'][street][index]);
                    console.log(area_data['paths'][street][index+1]);
                    console.log(elevation_diff / run_distance * 100);
                    console.log('----')

                    var grade = elevation_diff / run_distance * 100;
                    var grade_div_5 = Math.floor(grade / 5);
                    var grade_mod_5_div_5 = grade % 5 / 5;

                    /*
                        0-5 % grade: green to yellow
                        5-10 % grade: yellow to orange
                        10-15 % : orange to red
                        15+% red

                        example grades:
                            McAllister (Divis to Brod) - 6.2%
                            Broderick (Fulton to McAllister) - 8.5%
                            Baker (Fulton to McAllister) - 4.7%
                    */

                    var color = "#FF0000"; // default red
                    var green = {r:0, g: 255, b: 0};
                    var yellow = {r:255, g:255, b:0};
                    var orange = {r:255, g:123, b:0};
                    var red = {r: 255, g: 0, b: 0};

                    switch(grade_div_5) {
                    case 0:
                        color = makeGradientColor(green, yellow, grade_mod_5_div_5);
                        break;
                    case 1:
                        color = makeGradientColor(yellow, orange, grade_mod_5_div_5);
                        break;
                    case 2:
                        color = makeGradientColor(orange, red, grade_mod_5_div_5);
                        break;
                    }


                    var line = new google.maps.Polyline({
                      // https://developers.google.com/maps/documentation/javascript/overlays#PolylineOptions
                      path: lineCoordinates,
                      strokeColor: color,
                      strokeOpacity: 0.5,
                      strokeWeight: 8,
                      map: map
                    });

                    // no arrows for flat routes
                    //if (Math.floor(elevation_diff / 5) == 0) {
                    //    continue;
                    //}
                    var arrows = new google.maps.Polyline({
                      // https://developers.google.com/maps/documentation/javascript/overlays#PolylineOptions
                      path: lineCoordinates,
                      icons: [{
                        icon: lineSymbol,
                        offset: '0',
                        repeat: '20px'
                      }],
                      strokeOpacity: 0.5,
                      strokeWeight: 1,
                      map: map
                    });


                }
            }
        });

      }
    </script>
  </head>
  <body onload="initialize()">
    <div id="map_canvas" style="width:100%; height:100%"></div>
  </body>
</html>

<!--
http://maps.googleapis.com/maps/api/geocode/json?address=1st+and+Folsom,+San+Francisco,+CA&sensor=false
https://developers.google.com/maps/documentation/geocoding/index#GeocodingResponses

https://developers.google.com/maps/documentation/javascript/geocoding

Get all intersections in the city.

Get all elevations of all intersections in the city.
https://developers.google.com/maps/documentation/elevation/#ElevationRequests
http://maps.googleapis.com/maps/api/elevation/json?locations=37.78732780,-122.39444910&sensor=false

Store all that shit.
Create overlays to map them
https://developers.google.com/maps/documentation/javascript/overlays#Polylines

# colored and arrowed based on elevation up / down.

HARD: how to make all the overlays? how do you determine "neighboring intersections"?
    - how about defining via street? i.e. 'Geary Blvd': ['Geary and 1st', 'Geary and 2nd', 'Geary and 3rd', etc.]

DATA:
    - cities -> set of streets                          === DEFINED BY ME ===
    - streets -> ordered list of intersections          === DEFINED BY ME ===
    - intersections -> lat/long/elevation               === SCRAPED AND CACHED ===

for each street:
    for each ordered intersection in street:
        get elevation and location info for intersection, next intersection
        create overlay for intersection -> next intersection
            (rearrange lineCoordinates so that arrows point downhill)


Use of the Google Geocoding API is subject to a query limit of 2,500 geolocation requests per day. (User of Google Maps API for Business may perform up to 100,000 requests per day.)

Web sites and applications using the Google Maps API may at no cost generate up to 25,000 map loads per day for each service.


SNAP TO ROAD: two adjacent intersections on a CURVY road?
    http://stackoverflow.com/questions/10513360/polyline-snap-to-road-using-google-maps-api-v3

Use of the Google Directions API is subject to a query limit of 2,500 directions requests per day. Each directions search will count as a single request against your daily quota when the mode of transportation is driving, walking or cycling. Searching for transit directions will count as 4 requests.
-->
